<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fungo (fungo.Fungo)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">fungo</a> &#x00BB; Fungo</nav><h1>Module <code>Fungo</code></h1><p>This module provides a set of functions to work with point-free programming and function composition in a Haskellish style.</p><dl><dt>author</dt><dd>Marcelo Camargo</dd></dl></header><dl><dt class="spec type" id="type-predicate"><a href="#type-predicate" class="anchor"></a><code><span class="keyword">type </span>'a predicate</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>A predicate is a function from a value <code>'a</code> to a bool.</p></dd></dl><dl><dt class="spec value" id="val-always"><a href="#val-always" class="anchor"></a><code><span class="keyword">val </span>always : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>The <code>K</code> combinator. Always returns the first given argument.</p></dd></dl><dl><dt class="spec value" id="val-apply_to"><a href="#val-apply_to" class="anchor"></a><code><span class="keyword">val </span>apply_to : <span class="type-var">'a</span> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Takes a value and applies a function to it. This function is also known as the <code>thrush</code> combinator.</p></dd></dl><dl><dt class="spec value" id="val-both"><a href="#val-both" class="anchor"></a><code><span class="keyword">val </span>both : <span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>A function which receives two predicates and a value and returns whether the two predicates pass.</p></dd></dl><dl><dt class="spec value" id="val-complement"><a href="#val-complement" class="anchor"></a><code><span class="keyword">val </span>complement : <span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Takes a predicate function <code>f</code> and returns its complement (negation).</p></dd></dl><dl><dt class="spec value" id="val-compose"><a href="#val-compose" class="anchor"></a><code><span class="keyword">val </span>compose : (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Function composition.</p></dd></dl><dl><dt class="spec value" id="val-converge"><a href="#val-converge" class="anchor"></a><code><span class="keyword">val </span>converge : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> ((<span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)<span class="keyword"> * </span>(<span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)) <span>&#45;&gt;</span> <span class="type-var">'d</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Accepts a converging function and a pair of branching functions and returns a new function that receives a value and applies each branching function in the pair to it, them applies the converging function.</p></dd></dl><dl><dt class="spec value" id="val-either"><a href="#val-either" class="anchor"></a><code><span class="keyword">val </span>either : <span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>A function which receives two predicates and returns whether any of the predicates pass.</p></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">val </span>flip : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Flips the arguments of a binary function.</p></dd></dl><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val </span>id : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>The identity function.</p></dd></dl><dl><dt class="spec value" id="val-otherwise"><a href="#val-otherwise" class="anchor"></a><code><span class="keyword">val </span>otherwise : <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p>A function that always returns <code>true</code>. Use with <a href="index.html#val-whenever"><code>whenever</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pipe"><a href="#val-pipe" class="anchor"></a><code><span class="keyword">val </span>pipe : (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> (<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Reverse function composition, applying from left to right.</p></dd></dl><dl><dt class="spec value" id="val-tap"><a href="#val-tap" class="anchor"></a><code><span class="keyword">val </span>tap : (<span class="type-var">'a</span> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Runs the given function with the supplied value, then returns it.</p></dd></dl><dl><dt class="spec value" id="val-unless"><a href="#val-unless" class="anchor"></a><code><span class="keyword">val </span>unless : <span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Given a predicate function and a transformation, returns a function that receives a value and, if the value does not pass the predicate, returns the transformation applied to the value. Returns the identity when the value passes the predicate. It is the <a href="index.html#val-complement"><code>complement</code></a> of <a href="index.html#val-when_"><code>when_</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-when_"><a href="#val-when_" class="anchor"></a><code><span class="keyword">val </span>when_ : <span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a> <span>&#45;&gt;</span> (<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Given a predicate function and a transformation, returns a function that receives a value and, if the value passe the predicate, returns the transformation applied to the value. Returns the identity when the value does not pass the predicate. It is the <a href="index.html#val-complement"><code>complement</code></a> of <a href="index.html#val-unless"><code>unless</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-whenever"><a href="#val-whenever" class="anchor"></a><code><span class="keyword">val </span>whenever : (<span class="type-var">'a</span> <a href="index.html#type-predicate">predicate</a><span class="keyword"> * </span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)) list <span>&#45;&gt;</span> otherwise:(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>) <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p>Receives a list of pairs of predicates and transformations and applies the left side of each pair to the given value until a predicate passes. When the predicate passes, returns the value transformed with the second function of the given pair. The <code>~otherwise</code> parameter specifies the default case when there are no matches.</p></dd></dl><dl><dt class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module </span><a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Infix operations over functions.</p></dd></dl></div></body></html>